"use strict";(self.webpackChunkAutox_ozobi_Docs=self.webpackChunkAutox_ozobi_Docs||[]).push([["5884"],{6593:function(e,r,n){n.r(r),n.d(r,{default:()=>l});var s=n(5893),c=n(65);function i(e){let r=Object.assign({h1:"h1",a:"a",div:"div",p:"p",pre:"pre",code:"code",h3:"h3",ul:"ul",li:"li"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"module-模块",children:["module (模块)",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#module-模块",children:"#"})]}),"\n",(0,s.jsxs)(r.div,{className:"rspress-directive tip",children:[(0,s.jsx)(r.div,{className:"rspress-directive-title",children:"稳定性: 稳定"}),(0,s.jsx)(r.div,{className:"rspress-directive-content",children:"\n"})]}),"\n",(0,s.jsx)(r.p,{children:"Auto.js 有一个简单的模块加载系统。 在 Auto.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）。"}),"\n",(0,s.jsx)(r.p,{children:"例子，假设有一个名为 foo.js 的文件："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'var circle = require("./circle.js");\nconsole.log("半径为 4 的圆的面积是 %d", circle.area(4));\n'})}),"\n",(0,s.jsx)(r.p,{children:"在第一行中，foo.js 加载了同一目录下的 circle.js 模块。"}),"\n",(0,s.jsx)(r.p,{children:"circle.js 文件的内容为："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"const PI = Math.PI;\n\nexports.area = function (r) {\n    return PI * r * r;\n};\n\nexports.circumference = (r) => 2 * PI * r;\n"})}),"\n",(0,s.jsx)(r.p,{children:"circle.js 模块导出了 area() 和 circumference() 两个函数。 通过在特殊的 exports 对象上指定额外的属性，函数和对象可以被添加到模块的根部。"}),"\n",(0,s.jsx)(r.p,{children:"模块内的本地变量是私有的。 在这个例子中，变量 PI 是 circle.js 私有的，不会影响到加载他的脚本的变量环境。"}),"\n",(0,s.jsx)(r.p,{children:"module.exports 属性可以被赋予一个新的值（例如函数或对象）。"}),"\n",(0,s.jsx)(r.p,{children:"如下，bar.js 会用到 square 模块，square 导出一个构造函数："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'const square = require("./square.js");\nconst mySquare = square(2);\nconsole.log("正方形的面积是 %d", mySquare.area());\n'})}),"\n",(0,s.jsx)(r.p,{children:"square 模块定义在 square.js 中："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"// 赋值给 `exports` 不会修改模块，必须使用 `module.exports`\nmodule.exports = function (width) {\n    return {\n        area: () => width ** 2,\n    };\n};\n"})}),"\n",(0,s.jsxs)(r.h3,{id:"require函数",children:[(0,s.jsx)(r.code,{children:"require"}),"函数",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#require函数",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"require"}),"函数用于加载模块，返回模块中",(0,s.jsx)(r.code,{children:"module.exports"}),"的值。"]}),"\n",(0,s.jsxs)(r.p,{children:["该函数有一个参数用于查找模块位置，可以是相对路径(以'./'或'../'开头)，也可以是绝对路径(以'/'开头)，\n还可以是以'http://'或'https://'开头的 uri 地址，用于加载网络模块，出于安全和加载速度考虑，此方式","不建议使用","。"]}),"\n",(0,s.jsxs)(r.p,{children:["当没有以这些开头时，将会视为内置模块，从内置模块目录依次查找，由于历史原因，在脚本主文件中仍然会先尝试解析成相对路径解析，若解析成功则会忽略内置模块直接加载，","强烈不建议使用此方式加载相对路径的模块，该方式在模块中不可用并且被弃用，在未来版本可能会被移除。"]}),"\n",(0,s.jsx)(r.p,{children:"和 nodejs 类似，当传入的是一个目录，则会尝试加载该目录下的 index.js 文件，若存在 package.json 文件则会先解析该文件中的 main 字段，若 main 字段指向一个有效的模块将直接加载该模块。"}),"\n",(0,s.jsxs)(r.h3,{id:"模块变量",children:["模块变量",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#模块变量",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"这些变量只存在于模块中，并非全局变量"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"module"})," 储存当前模块一些信息的对象，其中最重要的是",(0,s.jsx)(r.code,{children:"module.exports"}),"表示该模块导出的对象"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"exports"})," 相当于预先运行了",(0,s.jsx)(r.code,{children:"var exports = module.exports"})]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"__dirname"})," 当前模块的目录名"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"__filename"})," 当前模块的文件名。 这是当前模块文件的已解析符号链接的绝对路径。"]}),"\n"]}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,c.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["doc%2Fadvanced%2Fmodules.md"]={toc:[{text:"`require`函数",id:"require函数",depth:3},{text:"模块变量",id:"模块变量",depth:3}],title:"module (模块)",headingTitle:"module (模块)",frontmatter:{}}}}]);