"use strict";(self.webpackChunkAutox_ozobi_Docs=self.webpackChunkAutox_ozobi_Docs||[]).push([["5446"],{8684:function(n,e,s){s.r(e),s.d(e,{default:()=>o});var r=s(5893),t=s(65);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre"},(0,t.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"线程通信",children:["线程通信",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#线程通信",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["Auto.js 提供了一些简单的设施来支持简单的线程通信。",(0,r.jsx)(e.code,{children:"threads.disposable()"}),"用于一个线程等待另一个线程的(一次性)结果，同时",(0,r.jsx)(e.code,{children:"Lock.newCondition()"}),"提供了 Condition 对象用于一般的线程通信(await, signal)。另外，",(0,r.jsx)(e.code,{children:"events"}),"模块也可以用于线程通信，通过指定",(0,r.jsx)(e.code,{children:"EventEmiiter"}),"的回调执行的线程来实现。"]}),"\n",(0,r.jsxs)(e.p,{children:["使用",(0,r.jsx)(e.code,{children:"threads.disposable()"}),'可以简单地等待和获取某个线程的执行结果。例如要等待某个线程计算"1+.....+10000":']}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'var sum = threads.disposable();\n//启动子线程计算\nthreads.start(function () {\n    var s = 0;\n    //从1加到10000\n    for (var i = 1; i <= 10000; i++) {\n        s += i;\n    }\n    //通知主线程接收结果\n    sum.setAndNotify(s);\n});\n//blockedGet()用于等待结果\ntoast("sum = " + sum.blockedGet());\n'})}),"\n",(0,r.jsxs)(e.p,{children:["如果上述代码用",(0,r.jsx)(e.code,{children:"Condition"}),"实现："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'//新建一个锁\nvar lock = threads.lock();\n//新建一个条件，即"计算完成"\nvar complete = lock.newCondition();\nvar sum = 0;\nthreads.start(function () {\n    //从1加到10000\n    for (var i = 1; i <= 10000; i++) {\n        sum += i;\n    }\n    //通知主线程接收结果\n    lock.lock();\n    complete.signal();\n    lock.unlock();\n});\n//等待计算完成\nlock.lock();\ncomplete.await();\nlock.unlock();\n//打印结果\ntoast("sum = " + sum);\n'})}),"\n",(0,r.jsxs)(e.p,{children:["如果上诉代码用",(0,r.jsx)(e.code,{children:"events"}),"模块实现："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'//新建一个emitter, 并指定回调执行的线程为当前线程\nvar sum = events.emitter(threads.currentThread());\nthreads.start(function () {\n    var s = 0;\n    //从1加到10000\n    for (var i = 1; i <= 10000; i++) {\n        s += i;\n    }\n    //发送事件result通知主线程接收结果\n    sum.emit("result", s);\n});\nsum.on("result", function (s) {\n    toastLog("sum = " + s + ", 当前线程: " + threads.currentThread());\n});\n'})}),"\n",(0,r.jsxs)(e.p,{children:["有关线程的其他问题，例如生产者消费者等问题，请用 Java 相关方法解决，例如",(0,r.jsx)(e.code,{children:"java.util.concurrent.BlockingQueue"}),"。"]})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["doc%2Fadvanced%2Fthreads%2F%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.md"]={toc:[],title:"线程通信",headingTitle:"线程通信",frontmatter:{}}}}]);