"use strict";(self.webpackChunkAutox_ozobi_Docs=self.webpackChunkAutox_ozobi_Docs||[]).push([["3905"],{6870:function(n,e,c){c.r(e),c.d(e,{default:()=>i});var s=c(5893),r=c(65);function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",code:"code",pre:"pre",h2:"h2",ul:"ul",li:"li"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"线程安全",children:["线程安全",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#线程安全",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"线程安全问题是一个相对专业的编程问题，本章节只提供给有需要的用户。"}),"\n",(0,s.jsx)(e.p,{children:"引用维基百科的解释："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:'在 Auto.js 中，线程间变量在符合 JavaScript 变量作用域规则的前提下是共享的，例如全局变量在所有线程都能访问，并且保证他们在所有线程的可见性。但是，不保证任何操作的原子性。例如经典的自增"i++"将不是原子性操作。'}),"\n",(0,s.jsxs)(e.p,{children:["Rhino 和 Auto.js 提供了一些简单的设施来解决简单的线程安全问题，如锁",(0,s.jsx)(e.code,{children:"threads.lock()"}),", 函数同步锁",(0,s.jsx)(e.code,{children:"sync()"}),", 整数原子变量",(0,s.jsx)(e.code,{children:"threads.atomic()"}),"等。"]}),"\n",(0,s.jsxs)(e.p,{children:["例如，对于多线程共享下的整数的自增操作(自增操作会导致问题，是因为自增操作实际上为",(0,s.jsx)(e.code,{children:"i = i + 1"}),"，也就是先读取 i 的值, 把他加 1, 再赋值给 i, 如果两个线程同时进行自增操作，可能出现 i 的值只增加了 1 的情况)，应该使用",(0,s.jsx)(e.code,{children:"threads.atomic()"}),"函数来新建一个整数原子变量，或者使用锁",(0,s.jsx)(e.code,{children:"threads.lock()"}),"来保证操作的原子性，或者用",(0,s.jsx)(e.code,{children:"sync()"}),"来增加同步锁。"]}),"\n",(0,s.jsx)(e.p,{children:"线程不安全的代码如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"var i = 0;\nthreads.start(function () {\n    while (true) {\n        log(i++);\n    }\n});\nwhile (true) {\n    log(i++);\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"此段代码运行后打开日志，可以看到日志中有重复的值出现。"}),"\n",(0,s.jsxs)(e.p,{children:["使用",(0,s.jsx)(e.code,{children:"threads.atomic()"}),"的线程安全的代码如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"//atomic返回的对象保证了自增的原子性\nvar i = threads.atomic();\nthreads.start(function () {\n    while (true) {\n        log(i.getAndIncrement());\n    }\n});\nwhile (true) {\n    log(i.getAndIncrement());\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"或者:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"//锁保证了操作的原子性\nvar lock = threads.lock();\nvar i = 0;\nthreads.start(function () {\n    while (true) {\n        lock.lock();\n        log(i++);\n        lock.unlock();\n    }\n});\nwhile (true) {\n    lock.lock();\n    log(i++);\n    lock.unlock();\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"或者:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"//sync函数会把里面的函数加上同步锁，使得在同一时刻最多只能有一个线程执行这个函数\nvar i = 0;\nvar getAndIncrement = sync(function () {\n    return i++;\n});\nthreads.start(function () {\n    while (true) {\n        log(getAndIncrement());\n    }\n});\nwhile (true) {\n    log(getAndIncrement());\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["另外，数组 Array 不是线程安全的，如果有这种复杂的需求，请用 Android 和 Java 相关 API 来实现。例如",(0,s.jsx)(e.code,{children:"CopyOnWriteList"}),", ",(0,s.jsx)(e.code,{children:"Vector"}),"等都是代替数组的线程安全的类，用于不同的场景。例如:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'var nums = new java.util.Vector();\nnums.add(123);\nnums.add(456);\ntoast("长度为" + nums.size());\ntoast("第一个元素为" + nums.get(0));\n'})}),"\n",(0,s.jsxs)(e.p,{children:["但很明显的是，这些类不像数组那样简便易用，也不能使用诸如",(0,s.jsx)(e.code,{children:"slice()"}),"之类的方便的函数。在未来可能会加入线程安全的数组来解决这个问题。当然您也可以为每个数组的操作加锁来解决线程安全问题："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'var nums = [];\nvar numsLock = threads.lock();\nthreads.start(function () {\n    //向数组添加元素123\n    numsLock.lock();\n    nums.push(123);\n    log("线程: %s, 数组: %s", threads.currentThread(), nums);\n    numsLock.unlock();\n});\n\nthreads.start(function () {\n    //向数组添加元素456\n    numsLock.lock();\n    nums.push(456);\n    log("线程: %s, 数组: %s", threads.currentThread(), nums);\n    numsLock.unlock();\n});\n\n//删除数组最后一个元素\nnumsLock.lock();\nnums.pop();\nlog("线程: %s, 数组: %s", threads.currentThread(), nums);\nnumsLock.unlock();\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"syncfunc",children:["sync(func)",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#syncfunc",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"func"})," {Function} 函数"]}),"\n",(0,s.jsx)(e.li,{children:"返回 {Function}"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"给函数 func 加上同步锁并作为一个新函数返回。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"var i = 0;\nfunction add(x) {\n    i += x;\n}\n\nvar syncAdd = sync(add);\nsyncAdd(10);\ntoast(i);\n"})})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["doc%2Fadvanced%2Fthreads%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.md"]={toc:[{text:"sync(func)",id:"syncfunc",depth:2}],title:"线程安全",headingTitle:"线程安全",frontmatter:{}}}}]);