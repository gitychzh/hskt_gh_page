"use strict";(self.webpackChunkAutox_ozobi_Docs=self.webpackChunkAutox_ozobi_Docs||[]).push([["7288"],{2784:function(e,a,r){r.r(a),r.d(a,{default:()=>s});var t=r(5893),d=r(65);function i(e){let a=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",h2:"h2",ul:"ul",li:"li"},(0,d.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(a.h1,{id:"thread",children:["Thread",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#thread",children:"#"})]}),"\n",(0,t.jsxs)(a.p,{children:["线程对象，",(0,t.jsx)(a.code,{children:"threads.start()"}),"返回的对象，用于获取和控制线程的状态，与其他线程交互等。"]}),"\n",(0,t.jsxs)(a.p,{children:["Thread 对象提供了和 timers 模块一样的 API，例如",(0,t.jsx)(a.code,{children:"setTimeout()"}),", ",(0,t.jsx)(a.code,{children:"setInterval()"}),"等，用于在该线程执行相应的定时回调，从而使线程之间可以直接交互。例如："]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:'var thread = threads.start(function () {\n    //在子线程执行的定时器\n    setInterval(function () {\n        log("子线程:" + threads.currentThread());\n    }, 1000);\n});\n\nlog("当前线程为主线程:" + threads.currentThread());\n\n//等待子线程启动\nthread.waitFor();\n//在子线程执行的定时器\nthread.setTimeout(function () {\n    //这段代码会在子线程执行\n    log("当前线程为子线程:" + threads.currentThread());\n}, 2000);\n\nsleep(30 * 1000);\nthread.interrupt();\n'})}),"\n",(0,t.jsxs)(a.h2,{id:"threadinterrupt",children:["Thread.interrupt()",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadinterrupt",children:"#"})]}),"\n",(0,t.jsx)(a.p,{children:"中断线程运行。"}),"\n",(0,t.jsxs)(a.h2,{id:"threadjointimeout",children:["Thread.join([timeout])",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadjointimeout",children:"#"})]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.code,{children:"timeout"})," {number} 等待时间，单位毫秒"]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"等待线程执行完成。如果 timeout 为 0，则会一直等待直至该线程执行完成；否则最多等待 timeout 毫秒的时间。"}),"\n",(0,t.jsx)(a.p,{children:"例如:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:'var sum = 0;\n//启动子线程计算1加到10000\nvar thread = threads.start(function () {\n    for (var i = 0; i < 10000; i++) {\n        sum += i;\n    }\n});\n//等待该线程完成\nthread.join();\ntoast("sum = " + sum);\n'})}),"\n",(0,t.jsxs)(a.h2,{id:"threadisalive",children:["Thread.isAlive()",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadisalive",children:"#"})]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"返回 {boolean}"}),"\n"]}),"\n",(0,t.jsxs)(a.p,{children:["返回线程是否存活。如果线程仍未开始或已经结束，返回",(0,t.jsx)(a.code,{children:"false"}),"; 如果线程已经开始或者正在运行中，返回",(0,t.jsx)(a.code,{children:"true"}),"。"]}),"\n",(0,t.jsxs)(a.h2,{id:"threadwaitfor",children:["Thread.waitFor()",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadwaitfor",children:"#"})]}),"\n",(0,t.jsxs)(a.p,{children:["等待线程开始执行。调用",(0,t.jsx)(a.code,{children:"threads.start()"}),"以后线程仍然需要一定时间才能开始执行，因此调用此函数会等待线程开始执行；如果线程已经处于执行状态则立即返回。"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:"var thread = threads.start(function () {\n    //do something\n});\nthread.waitFor();\nthread.setTimeout(function () {\n    //do something\n}, 1000);\n"})}),"\n",(0,t.jsxs)(a.h2,{id:"threadsettimeoutcallback-delay-args",children:["Thread.setTimeout(callback, delay[, ...args])",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadsettimeoutcallback-delay-args",children:"#"})]}),"\n",(0,t.jsxs)(a.p,{children:["参见",(0,t.jsx)(a.a,{href:"/timers#settimeoutcallback-delay-args",children:"timers.setTimeout"}),"。"]}),"\n",(0,t.jsxs)(a.p,{children:["区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出",(0,t.jsx)(a.code,{children:"IllegalStateException"}),"。"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-js",children:'log("当前线程(主线程):" + threads.currentThread());\n\nvar thread = threads.start(function () {\n    //设置一个空的定时来保持线程的运行状态\n    setInterval(function () {}, 1000);\n});\n\nsleep(1000);\nthread.setTimeout(function () {\n    log("当前线程(子线程):" + threads.currentThread());\n    exit();\n}, 1000);\n'})}),"\n",(0,t.jsxs)(a.h2,{id:"threadsetintervalcallback-delay-args",children:["Thread.setInterval(callback, delay[, ...args])",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadsetintervalcallback-delay-args",children:"#"})]}),"\n",(0,t.jsxs)(a.p,{children:["参见",(0,t.jsx)(a.a,{href:"/timers#setintervalcallback-delay-args",children:"timers.setInterval()"}),"。"]}),"\n",(0,t.jsxs)(a.p,{children:["区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出",(0,t.jsx)(a.code,{children:"IllegalStateException"}),"。"]}),"\n",(0,t.jsxs)(a.h2,{id:"threadsetimmediatecallback-args",children:["Thread.setImmediate(callback[, ...args])",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadsetimmediatecallback-args",children:"#"})]}),"\n",(0,t.jsxs)(a.p,{children:["参见",(0,t.jsx)(a.a,{href:"/timers#setimmediatecallback-args",children:"timers.setImmediate"}),"。"]}),"\n",(0,t.jsxs)(a.p,{children:["区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出",(0,t.jsx)(a.code,{children:"IllegalStateException"}),"。"]}),"\n",(0,t.jsxs)(a.h2,{id:"threadclearintervalid",children:["Thread.clearInterval(id)",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadclearintervalid",children:"#"})]}),"\n",(0,t.jsxs)(a.p,{children:["参见",(0,t.jsx)(a.a,{href:"/timers#clearintervalid",children:"timers.clearInterval()"}),"。"]}),"\n",(0,t.jsxs)(a.p,{children:["区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出",(0,t.jsx)(a.code,{children:"IllegalStateException"}),"。"]}),"\n",(0,t.jsxs)(a.h2,{id:"threadcleartimeoutid",children:["Thread.clearTimeout(id)",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadcleartimeoutid",children:"#"})]}),"\n",(0,t.jsxs)(a.p,{children:["参见",(0,t.jsx)(a.a,{href:"/timers#cleartimeoutid",children:"timers.clearTimeout()"}),"。"]}),"\n",(0,t.jsxs)(a.p,{children:["区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出",(0,t.jsx)(a.code,{children:"IllegalStateException"}),"。"]}),"\n",(0,t.jsxs)(a.h2,{id:"threadclearimmediateid",children:["Thread.clearImmediate(id)",(0,t.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#threadclearimmediateid",children:"#"})]}),"\n",(0,t.jsxs)(a.p,{children:["参见",(0,t.jsx)(a.a,{href:"/timers#clearimmediateid",children:"timers.clearImmediate()"}),"。"]}),"\n",(0,t.jsxs)(a.p,{children:["区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出",(0,t.jsx)(a.code,{children:"IllegalStateException"}),"。"]})]})}function n(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:a}=Object.assign({},(0,d.ah)(),e.components);return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}let s=n;n.__RSPRESS_PAGE_META={},n.__RSPRESS_PAGE_META["doc%2Fadvanced%2Fthreads%2Fthread.md"]={toc:[{text:"Thread.interrupt()",id:"threadinterrupt",depth:2},{text:"Thread.join([timeout])",id:"threadjointimeout",depth:2},{text:"Thread.isAlive()",id:"threadisalive",depth:2},{text:"Thread.waitFor()",id:"threadwaitfor",depth:2},{text:"Thread.setTimeout(callback, delay[, ...args])",id:"threadsettimeoutcallback-delay-args",depth:2},{text:"Thread.setInterval(callback, delay[, ...args])",id:"threadsetintervalcallback-delay-args",depth:2},{text:"Thread.setImmediate(callback[, ...args])",id:"threadsetimmediatecallback-args",depth:2},{text:"Thread.clearInterval(id)",id:"threadclearintervalid",depth:2},{text:"Thread.clearTimeout(id)",id:"threadcleartimeoutid",depth:2},{text:"Thread.clearImmediate(id)",id:"threadclearimmediateid",depth:2}],title:"Thread",headingTitle:"Thread",frontmatter:{}}}}]);